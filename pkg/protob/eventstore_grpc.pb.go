// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protob

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// KVClient is the client API for KV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KVClient interface {
	// Set KV at storage
	Set(ctx context.Context, in *SetKVRequest, opts ...grpc.CallOption) (*SetKVResponse, error)
	// Incr increments an integer value from storage
	Incr(ctx context.Context, in *IncrKVRequest, opts ...grpc.CallOption) (*IncrKVResponse, error)
	// Decr decrements an integer value from storage
	Decr(ctx context.Context, in *DecrKVRequest, opts ...grpc.CallOption) (*DecrKVResponse, error)
	// Del item from storage
	Del(ctx context.Context, in *DelKVRequest, opts ...grpc.CallOption) (*DelKVResponse, error)
	// Get item from storage
	Get(ctx context.Context, in *GetKVRequest, opts ...grpc.CallOption) (*GetKVResponse, error)
	// Lock the key for exclusive access
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock the key
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
}

type kVClient struct {
	cc grpc.ClientConnInterface
}

func NewKVClient(cc grpc.ClientConnInterface) KVClient {
	return &kVClient{cc}
}

func (c *kVClient) Set(ctx context.Context, in *SetKVRequest, opts ...grpc.CallOption) (*SetKVResponse, error) {
	out := new(SetKVResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Incr(ctx context.Context, in *IncrKVRequest, opts ...grpc.CallOption) (*IncrKVResponse, error) {
	out := new(IncrKVResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Incr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Decr(ctx context.Context, in *DecrKVRequest, opts ...grpc.CallOption) (*DecrKVResponse, error) {
	out := new(DecrKVResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Decr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Del(ctx context.Context, in *DelKVRequest, opts ...grpc.CallOption) (*DelKVResponse, error) {
	out := new(DelKVResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Get(ctx context.Context, in *GetKVRequest, opts ...grpc.CallOption) (*GetKVResponse, error) {
	out := new(GetKVResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Lock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, "/protob.KV/Unlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVServer is the server API for KV service.
// All implementations must embed UnimplementedKVServer
// for forward compatibility
type KVServer interface {
	// Set KV at storage
	Set(context.Context, *SetKVRequest) (*SetKVResponse, error)
	// Incr increments an integer value from storage
	Incr(context.Context, *IncrKVRequest) (*IncrKVResponse, error)
	// Decr decrements an integer value from storage
	Decr(context.Context, *DecrKVRequest) (*DecrKVResponse, error)
	// Del item from storage
	Del(context.Context, *DelKVRequest) (*DelKVResponse, error)
	// Get item from storage
	Get(context.Context, *GetKVRequest) (*GetKVResponse, error)
	// Lock the key for exclusive access
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock the key
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	mustEmbedUnimplementedKVServer()
}

// UnimplementedKVServer must be embedded to have forward compatible implementations.
type UnimplementedKVServer struct {
}

func (UnimplementedKVServer) Set(context.Context, *SetKVRequest) (*SetKVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedKVServer) Incr(context.Context, *IncrKVRequest) (*IncrKVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Incr not implemented")
}
func (UnimplementedKVServer) Decr(context.Context, *DecrKVRequest) (*DecrKVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decr not implemented")
}
func (UnimplementedKVServer) Del(context.Context, *DelKVRequest) (*DelKVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Del not implemented")
}
func (UnimplementedKVServer) Get(context.Context, *GetKVRequest) (*GetKVResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedKVServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedKVServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedKVServer) mustEmbedUnimplementedKVServer() {}

// UnsafeKVServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KVServer will
// result in compilation errors.
type UnsafeKVServer interface {
	mustEmbedUnimplementedKVServer()
}

func RegisterKVServer(s grpc.ServiceRegistrar, srv KVServer) {
	s.RegisterService(&KV_ServiceDesc, srv)
}

func _KV_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Set(ctx, req.(*SetKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Incr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Incr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Incr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Incr(ctx, req.(*IncrKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Decr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Decr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Decr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Decr(ctx, req.(*DecrKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Del(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Del(ctx, req.(*DelKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKVRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Get(ctx, req.(*GetKVRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.KV/Unlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KV_ServiceDesc is the grpc.ServiceDesc for KV service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KV_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protob.KV",
	HandlerType: (*KVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _KV_Set_Handler,
		},
		{
			MethodName: "Incr",
			Handler:    _KV_Incr_Handler,
		},
		{
			MethodName: "Decr",
			Handler:    _KV_Decr_Handler,
		},
		{
			MethodName: "Del",
			Handler:    _KV_Del_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _KV_Get_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _KV_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _KV_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/protob/eventstore.proto",
}

// MapClient is the client API for Map service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MapClient interface {
	// New map
	New(ctx context.Context, in *NewMapRequest, opts ...grpc.CallOption) (*NewMapResponse, error)
	// GetFields all KVs in map
	GetFields(ctx context.Context, in *GetAllMapFieldsRequest, opts ...grpc.CallOption) (*GetAllMapFieldsResponse, error)
	// Len for the map
	Len(ctx context.Context, in *LenMapRequest, opts ...grpc.CallOption) (*LenMapResponse, error)
	// Del map
	Del(ctx context.Context, in *DelMapRequest, opts ...grpc.CallOption) (*DelMapResponse, error)
	// FieldSet KV at map
	FieldSet(ctx context.Context, in *SetMapFieldRequest, opts ...grpc.CallOption) (*SetMapFieldResponse, error)
	// FieldIncr increments integer value at map
	FieldIncr(ctx context.Context, in *IncrMapFieldRequest, opts ...grpc.CallOption) (*IncrMapFieldResponse, error)
	// FieldDecr decrements integer value at map
	FieldDecr(ctx context.Context, in *DecrMapFieldRequest, opts ...grpc.CallOption) (*DecrMapFieldResponse, error)
	// FieldDel key at map
	FieldDel(ctx context.Context, in *DelMapFieldRequest, opts ...grpc.CallOption) (*DelMapFieldResponse, error)
	// FieldGet value at key
	FieldGet(ctx context.Context, in *GetMapFieldRequest, opts ...grpc.CallOption) (*GetMapFieldResponse, error)
	// Lock the map for exclusive access
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock the map
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
}

type mapClient struct {
	cc grpc.ClientConnInterface
}

func NewMapClient(cc grpc.ClientConnInterface) MapClient {
	return &mapClient{cc}
}

func (c *mapClient) New(ctx context.Context, in *NewMapRequest, opts ...grpc.CallOption) (*NewMapResponse, error) {
	out := new(NewMapResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/New", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) GetFields(ctx context.Context, in *GetAllMapFieldsRequest, opts ...grpc.CallOption) (*GetAllMapFieldsResponse, error) {
	out := new(GetAllMapFieldsResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/GetFields", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) Len(ctx context.Context, in *LenMapRequest, opts ...grpc.CallOption) (*LenMapResponse, error) {
	out := new(LenMapResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/Len", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) Del(ctx context.Context, in *DelMapRequest, opts ...grpc.CallOption) (*DelMapResponse, error) {
	out := new(DelMapResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/Del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) FieldSet(ctx context.Context, in *SetMapFieldRequest, opts ...grpc.CallOption) (*SetMapFieldResponse, error) {
	out := new(SetMapFieldResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/FieldSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) FieldIncr(ctx context.Context, in *IncrMapFieldRequest, opts ...grpc.CallOption) (*IncrMapFieldResponse, error) {
	out := new(IncrMapFieldResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/FieldIncr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) FieldDecr(ctx context.Context, in *DecrMapFieldRequest, opts ...grpc.CallOption) (*DecrMapFieldResponse, error) {
	out := new(DecrMapFieldResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/FieldDecr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) FieldDel(ctx context.Context, in *DelMapFieldRequest, opts ...grpc.CallOption) (*DelMapFieldResponse, error) {
	out := new(DelMapFieldResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/FieldDel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) FieldGet(ctx context.Context, in *GetMapFieldRequest, opts ...grpc.CallOption) (*GetMapFieldResponse, error) {
	out := new(GetMapFieldResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/FieldGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/Lock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, "/protob.Map/Unlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapServer is the server API for Map service.
// All implementations must embed UnimplementedMapServer
// for forward compatibility
type MapServer interface {
	// New map
	New(context.Context, *NewMapRequest) (*NewMapResponse, error)
	// GetFields all KVs in map
	GetFields(context.Context, *GetAllMapFieldsRequest) (*GetAllMapFieldsResponse, error)
	// Len for the map
	Len(context.Context, *LenMapRequest) (*LenMapResponse, error)
	// Del map
	Del(context.Context, *DelMapRequest) (*DelMapResponse, error)
	// FieldSet KV at map
	FieldSet(context.Context, *SetMapFieldRequest) (*SetMapFieldResponse, error)
	// FieldIncr increments integer value at map
	FieldIncr(context.Context, *IncrMapFieldRequest) (*IncrMapFieldResponse, error)
	// FieldDecr decrements integer value at map
	FieldDecr(context.Context, *DecrMapFieldRequest) (*DecrMapFieldResponse, error)
	// FieldDel key at map
	FieldDel(context.Context, *DelMapFieldRequest) (*DelMapFieldResponse, error)
	// FieldGet value at key
	FieldGet(context.Context, *GetMapFieldRequest) (*GetMapFieldResponse, error)
	// Lock the map for exclusive access
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock the map
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	mustEmbedUnimplementedMapServer()
}

// UnimplementedMapServer must be embedded to have forward compatible implementations.
type UnimplementedMapServer struct {
}

func (UnimplementedMapServer) New(context.Context, *NewMapRequest) (*NewMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method New not implemented")
}
func (UnimplementedMapServer) GetFields(context.Context, *GetAllMapFieldsRequest) (*GetAllMapFieldsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFields not implemented")
}
func (UnimplementedMapServer) Len(context.Context, *LenMapRequest) (*LenMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Len not implemented")
}
func (UnimplementedMapServer) Del(context.Context, *DelMapRequest) (*DelMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Del not implemented")
}
func (UnimplementedMapServer) FieldSet(context.Context, *SetMapFieldRequest) (*SetMapFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FieldSet not implemented")
}
func (UnimplementedMapServer) FieldIncr(context.Context, *IncrMapFieldRequest) (*IncrMapFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FieldIncr not implemented")
}
func (UnimplementedMapServer) FieldDecr(context.Context, *DecrMapFieldRequest) (*DecrMapFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FieldDecr not implemented")
}
func (UnimplementedMapServer) FieldDel(context.Context, *DelMapFieldRequest) (*DelMapFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FieldDel not implemented")
}
func (UnimplementedMapServer) FieldGet(context.Context, *GetMapFieldRequest) (*GetMapFieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FieldGet not implemented")
}
func (UnimplementedMapServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedMapServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedMapServer) mustEmbedUnimplementedMapServer() {}

// UnsafeMapServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MapServer will
// result in compilation errors.
type UnsafeMapServer interface {
	mustEmbedUnimplementedMapServer()
}

func RegisterMapServer(s grpc.ServiceRegistrar, srv MapServer) {
	s.RegisterService(&Map_ServiceDesc, srv)
}

func _Map_New_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).New(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/New",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).New(ctx, req.(*NewMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_GetFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllMapFieldsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).GetFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/GetFields",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).GetFields(ctx, req.(*GetAllMapFieldsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_Len_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LenMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).Len(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/Len",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).Len(ctx, req.(*LenMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).Del(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/Del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).Del(ctx, req.(*DelMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_FieldSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMapFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).FieldSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/FieldSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).FieldSet(ctx, req.(*SetMapFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_FieldIncr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrMapFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).FieldIncr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/FieldIncr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).FieldIncr(ctx, req.(*IncrMapFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_FieldDecr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrMapFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).FieldDecr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/FieldDecr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).FieldDecr(ctx, req.(*DecrMapFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_FieldDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelMapFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).FieldDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/FieldDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).FieldDel(ctx, req.(*DelMapFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_FieldGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapFieldRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).FieldGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/FieldGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).FieldGet(ctx, req.(*GetMapFieldRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Map/Unlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Map_ServiceDesc is the grpc.ServiceDesc for Map service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Map_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protob.Map",
	HandlerType: (*MapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "New",
			Handler:    _Map_New_Handler,
		},
		{
			MethodName: "GetFields",
			Handler:    _Map_GetFields_Handler,
		},
		{
			MethodName: "Len",
			Handler:    _Map_Len_Handler,
		},
		{
			MethodName: "Del",
			Handler:    _Map_Del_Handler,
		},
		{
			MethodName: "FieldSet",
			Handler:    _Map_FieldSet_Handler,
		},
		{
			MethodName: "FieldIncr",
			Handler:    _Map_FieldIncr_Handler,
		},
		{
			MethodName: "FieldDecr",
			Handler:    _Map_FieldDecr_Handler,
		},
		{
			MethodName: "FieldDel",
			Handler:    _Map_FieldDel_Handler,
		},
		{
			MethodName: "FieldGet",
			Handler:    _Map_FieldGet_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _Map_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _Map_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/protob/eventstore.proto",
}

// QueueClient is the client API for Queue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueueClient interface {
	// New queue
	New(ctx context.Context, in *NewQueueRequest, opts ...grpc.CallOption) (*NewQueueResponse, error)
	// GetAll all elements in queue
	GetAll(ctx context.Context, in *GetAllQueuesRequest, opts ...grpc.CallOption) (*GetAllQueuesResponse, error)
	// Len for the queue
	Len(ctx context.Context, in *LenQueueRequest, opts ...grpc.CallOption) (*LenQueueResponse, error)
	// Del queue
	Del(ctx context.Context, in *DelQueueRequest, opts ...grpc.CallOption) (*DelQueueResponse, error)
	// Push value in map
	Push(ctx context.Context, in *PushQueueRequest, opts ...grpc.CallOption) (*PushQueueResponse, error)
	// Index returns the element at the index
	Index(ctx context.Context, in *IndexQueueRequest, opts ...grpc.CallOption) (*IndexQueueResponse, error)
	// Pop retrieves and removes an element from the queue
	Pop(ctx context.Context, in *PopQueueRequest, opts ...grpc.CallOption) (*PopQueueResponse, error)
	// Peek retrieves an element from the queue
	Peek(ctx context.Context, in *PeekQueueRequest, opts ...grpc.CallOption) (*PeekQueueResponse, error)
}

type queueClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueClient(cc grpc.ClientConnInterface) QueueClient {
	return &queueClient{cc}
}

func (c *queueClient) New(ctx context.Context, in *NewQueueRequest, opts ...grpc.CallOption) (*NewQueueResponse, error) {
	out := new(NewQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/New", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) GetAll(ctx context.Context, in *GetAllQueuesRequest, opts ...grpc.CallOption) (*GetAllQueuesResponse, error) {
	out := new(GetAllQueuesResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Len(ctx context.Context, in *LenQueueRequest, opts ...grpc.CallOption) (*LenQueueResponse, error) {
	out := new(LenQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Len", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Del(ctx context.Context, in *DelQueueRequest, opts ...grpc.CallOption) (*DelQueueResponse, error) {
	out := new(DelQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Push(ctx context.Context, in *PushQueueRequest, opts ...grpc.CallOption) (*PushQueueResponse, error) {
	out := new(PushQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Push", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Index(ctx context.Context, in *IndexQueueRequest, opts ...grpc.CallOption) (*IndexQueueResponse, error) {
	out := new(IndexQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Index", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Pop(ctx context.Context, in *PopQueueRequest, opts ...grpc.CallOption) (*PopQueueResponse, error) {
	out := new(PopQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Pop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueClient) Peek(ctx context.Context, in *PeekQueueRequest, opts ...grpc.CallOption) (*PeekQueueResponse, error) {
	out := new(PeekQueueResponse)
	err := c.cc.Invoke(ctx, "/protob.Queue/Peek", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServer is the server API for Queue service.
// All implementations must embed UnimplementedQueueServer
// for forward compatibility
type QueueServer interface {
	// New queue
	New(context.Context, *NewQueueRequest) (*NewQueueResponse, error)
	// GetAll all elements in queue
	GetAll(context.Context, *GetAllQueuesRequest) (*GetAllQueuesResponse, error)
	// Len for the queue
	Len(context.Context, *LenQueueRequest) (*LenQueueResponse, error)
	// Del queue
	Del(context.Context, *DelQueueRequest) (*DelQueueResponse, error)
	// Push value in map
	Push(context.Context, *PushQueueRequest) (*PushQueueResponse, error)
	// Index returns the element at the index
	Index(context.Context, *IndexQueueRequest) (*IndexQueueResponse, error)
	// Pop retrieves and removes an element from the queue
	Pop(context.Context, *PopQueueRequest) (*PopQueueResponse, error)
	// Peek retrieves an element from the queue
	Peek(context.Context, *PeekQueueRequest) (*PeekQueueResponse, error)
	mustEmbedUnimplementedQueueServer()
}

// UnimplementedQueueServer must be embedded to have forward compatible implementations.
type UnimplementedQueueServer struct {
}

func (UnimplementedQueueServer) New(context.Context, *NewQueueRequest) (*NewQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method New not implemented")
}
func (UnimplementedQueueServer) GetAll(context.Context, *GetAllQueuesRequest) (*GetAllQueuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedQueueServer) Len(context.Context, *LenQueueRequest) (*LenQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Len not implemented")
}
func (UnimplementedQueueServer) Del(context.Context, *DelQueueRequest) (*DelQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Del not implemented")
}
func (UnimplementedQueueServer) Push(context.Context, *PushQueueRequest) (*PushQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedQueueServer) Index(context.Context, *IndexQueueRequest) (*IndexQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Index not implemented")
}
func (UnimplementedQueueServer) Pop(context.Context, *PopQueueRequest) (*PopQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pop not implemented")
}
func (UnimplementedQueueServer) Peek(context.Context, *PeekQueueRequest) (*PeekQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Peek not implemented")
}
func (UnimplementedQueueServer) mustEmbedUnimplementedQueueServer() {}

// UnsafeQueueServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServer will
// result in compilation errors.
type UnsafeQueueServer interface {
	mustEmbedUnimplementedQueueServer()
}

func RegisterQueueServer(s grpc.ServiceRegistrar, srv QueueServer) {
	s.RegisterService(&Queue_ServiceDesc, srv)
}

func _Queue_New_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).New(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/New",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).New(ctx, req.(*NewQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllQueuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).GetAll(ctx, req.(*GetAllQueuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Len_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LenQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Len(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Len",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Len(ctx, req.(*LenQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Del(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Del(ctx, req.(*DelQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Push(ctx, req.(*PushQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Index(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Index",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Index(ctx, req.(*IndexQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Pop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PopQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Pop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Pop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Pop(ctx, req.(*PopQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Queue_Peek_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeekQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServer).Peek(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Queue/Peek",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServer).Peek(ctx, req.(*PeekQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Queue_ServiceDesc is the grpc.ServiceDesc for Queue service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Queue_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protob.Queue",
	HandlerType: (*QueueServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "New",
			Handler:    _Queue_New_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _Queue_GetAll_Handler,
		},
		{
			MethodName: "Len",
			Handler:    _Queue_Len_Handler,
		},
		{
			MethodName: "Del",
			Handler:    _Queue_Del_Handler,
		},
		{
			MethodName: "Push",
			Handler:    _Queue_Push_Handler,
		},
		{
			MethodName: "Index",
			Handler:    _Queue_Index_Handler,
		},
		{
			MethodName: "Pop",
			Handler:    _Queue_Pop_Handler,
		},
		{
			MethodName: "Peek",
			Handler:    _Queue_Peek_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/protob/eventstore.proto",
}

// SyncClient is the client API for Sync service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncClient interface {
	// Lock key for exclusive access
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock key
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
}

type syncClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncClient(cc grpc.ClientConnInterface) SyncClient {
	return &syncClient{cc}
}

func (c *syncClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, "/protob.Sync/Lock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, "/protob.Sync/Unlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncServer is the server API for Sync service.
// All implementations must embed UnimplementedSyncServer
// for forward compatibility
type SyncServer interface {
	// Lock key for exclusive access
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock key
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	mustEmbedUnimplementedSyncServer()
}

// UnimplementedSyncServer must be embedded to have forward compatible implementations.
type UnimplementedSyncServer struct {
}

func (UnimplementedSyncServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedSyncServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedSyncServer) mustEmbedUnimplementedSyncServer() {}

// UnsafeSyncServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncServer will
// result in compilation errors.
type UnsafeSyncServer interface {
	mustEmbedUnimplementedSyncServer()
}

func RegisterSyncServer(s grpc.ServiceRegistrar, srv SyncServer) {
	s.RegisterService(&Sync_ServiceDesc, srv)
}

func _Sync_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Sync/Lock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sync_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protob.Sync/Unlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Sync_ServiceDesc is the grpc.ServiceDesc for Sync service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Sync_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protob.Sync",
	HandlerType: (*SyncServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lock",
			Handler:    _Sync_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _Sync_Unlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/protob/eventstore.proto",
}
